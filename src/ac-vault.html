<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/app-route/app-route.html">
<link rel="import" href="./ac-helpers.html">
<link rel="import" href="./ac-password.html">
<link rel="import" href="../bower_components/ac-input/ac-input.html">

<script src="scripts/lightwallet.min.js"></script>
<link rel="import" href="../bower_components/neon-animation/neon-animation.html">

<dom-module id="ac-vault">

  <style>
      :host {
        display: block;
      }

      .pascanvas {
      /*background-color: var(--ac-yellow);*/

      @apply(--locals-canvas);
      @apply(--base-structure);

      height: 100vh;
      @apply(--layout-vertical);
      @apply(--layout-center-center);
     }
     .enterpass {
     width: 80%;
     max-width: 500px;
     @apply(--layout-vertical);
     @apply(--layout-center-center);
    }

    .whitespace {
      height: 20px;
    }
    
    </style>

  <template>
    <ac-helpers id="helpers"></ac-helpers>
    <app-route route="{{route}}" pattern="/:page" data="{{data}}"></app-route>

    <neon-animated-pages attr-for-selected="data-page" selected="[[data.page]]" entry-animation="{{entryAnimation}}" exit-animation="{{exitAnimation}}">
      <!-- first stage in importing PK -->
      <neon-animatable data-page="importpk">
        <div class="pascanvas">
          <h1>Enter your privatekey</h1>
          <div class="enterpass">
            <ac-input id="privatekeyinut" color="yellow" id="inputpass" label="enter your private key" type="password" bind-value="{{privatekey}}" center></ac-input>
            <ac-button class="loginbtn" icon="ac-arrowright" on-tap="pkreceived" bg="base" txtcolor="yellow"></ac-button>
          </div>
        </div>
      </neon-animatable>

      <!-- second stage in importing PK -->
      <neon-animatable data-page="importpkmakewallet">
        <h1>
          Enter a password to protect the vault that will hold this key
        </h1>
        <ac-password double sessionname="vaultpassword" on-password-received="createvaultfrompk"></ac-password>
      </neon-animatable>

      <!-- import a keyfile -->
      <neon-animatable data-page="importfile">
        <input type="file"  class="hidden" id="uploaditem"  on-change="readSingleFile">
        <ac-button on-tap="uploadclick" txtbtn txtcolor="base" bg="yellow">Choose your wallet-file</ac-button>
      </neon-animatable>
<!-- 
      <neon-animatable data-page="new">
        <ac-button big class="yesno" bg="btncolor" txtcolor="red" on-tap="tocreatenew" txtbtn>Create a new vault</ac-button>
        <ac-button big class="yesno" bg="btncolor" txtcolor="red" on-tap="toimportfile" txtbtn>Import a wallet file</ac-button>
        <ac-button big class="yesno" bg="btncolor" txtcolor="red" on-tap="toimportpk" txtbtn>Enter a private key</ac-button>
      </neon-animatable> -->

      <neon-animatable data-page="createnew">
        <p class="yellow centertxt">Choose a password and repeat</p>
        <ac-password double sessionname="vaultpassword" on-password-received="createvault"></ac-password>
        <!-- <ac-createwallet on-to-home="toHome"></ac-createwallet>
      -->
    </neon-animatable>

    <neon-animatable data-page="unlock">
      <ac-password id="newuser" sessionname="vaultpassword" on-password-received="unlockvault"></ac-password>
    </neon-animatable>

  </neon-animated-pages>

</template>

<script>
    Polymer({

      is: 'ac-vault',

      properties: {
        route: {
          type: Object
        },
        password: {
          type: String,
        },
        keystore: {
          type: Object,
          notify: true,
        },
        // the exposed lightwallet.keystore object
        currentkeystore: {
          type: Object,
          notify: true,
        },
        // the ethereum account assiciated with the current identity
        currentaccount: {
          type: String,
          notify: true,
        },
        // an object containing a set of fields with identity data.
        currentidentity: {
          type: Object,
          notify: true
        }
      },

    observers: [
          '_onRoutePathChanged(data.page)'
        ],

        // tocreatenew: function(){
        //   this.set('route.path', '/createnew');   
        // },
        // toimportfile: function(){
        //   this.set('route.path', '/importfile');   
        // },
        // toimportpk: function(){
        //   this.set('route.path', '/importpk');   
        // },

      _onRoutePathChanged: function(page) {

        switch (page) {
          case 'importpk':
          case 'importpkmakewallet':
          case 'importfile':
          case 'createnew':
            if (this.hasVault()) {
              console.log('You already have a vault');
            }
            break;
          default:
            if (!this.hasVault()) {
              return this.fire('novault');
            };
            if (!this.password) {
              return this.fire('locked');
            }
            break;

        }
      },

      uploadclick: function() {
        document.querySelector('#uploaditem').click();
      },
      
      readSingleFile: function(e) {
        //debugger;
        var self = this;
        var file = e.target.files[0];
        if (!file) {
          return;
        }
        this.walletfilename = file.name;
        var reader = new FileReader();
        reader.onload = function(e) {
          var contents = e.target.result;
          self.readwallet = contents;
          //self.importWallet(contents);
        };
        reader.readAsText(file);
      },

      pkreceived: function(){
        this.set('route.path', '/importpkmakewallet');          
      },

      createvaultfrompk: function(e) {
        this.password = e.detail.password;
        this.createKeystore(0, function() {
          this._getpwDerivedKey(function(err, pwDerivedKey) {
            this.keystore.importPrivateKey(this.privatekey, pwDerivedKey);
            this.saveVault();
            this.loadVault();
            this.fire('unlocked');
          }.bind(this));
        }.bind(this));
      },

      attached: function(){
        console.log('ac-vault attached');
      },

      _currentidentity: function(){
        console.log('ac-vault ->','currentidentity updated',this.currentidentity);
      },


      unlockvault: function(e) {
        if (!this.hasVault()) {
          //return page.redirect('/');
          console.log("there is no vault!");
        }
        this.password = e.detail.password;
        this.loadVault();
        console.log("vault loaded!");
        this.fire('unlocked');
        //page.redirect('/home');
      },

      loadVault: function(){

        this.vault = JSON.parse(window.localStorage.getItem('ac-vault'));

        try{
          if(!this.vault){
            throw new Error('ac-vault: loadVault: vault is not defined.');
          }
          if (!this.password){
            throw new Error('ac-vault: loadVault: no password set.');            
          }
          switch (this.vault.version){

            case 1:
              this.keystore = lightwallet.keystore.deserialize(this.vault.keystore);
              this.currentaccount = this.$.helpers.fixaddress(this.keystore.getAddresses()[0]);
              this.currentidentity = this.vault.identity;
              console.log('ac-vault -> Vault opened. Account=',this.currentaccount);
              break;

            default:
              throw new Error('Vault version unknown',this.vault.version);
              break;
          }
        }
        catch(e){
          throw new Error('Vault could not be loaded',e);
        }

      },

      importPrivateKey: function(pk) {
        var self = this;
        this._getpwDerivedKey(function(err, pwDerivedKey) {
          self.keystore.importPrivateKey(pk, pwDerivedKey);
        });
      },

      saveVault: function(){

          var serializedKeystore = this.keystore.serialize();
          var serializedIdentity = this.currentidentity || {};

          var vault = {
            version:1,
            keystore: serializedKeystore,
            identity: serializedIdentity
          };

          //encryption.multiEncryptString(keystore, pwDerivedKey, msg, myPubKey, theirPubKeyArray [, hdPathString])

          window.localStorage.setItem('ac-vault', JSON.stringify(vault));

      },

      hasVault: function(){
        var vault = window.localStorage.getItem('ac-vault');
        return (vault);
      },

      createvault: function(e){
        this.password = e.detail.password;
        this.createKeystore(1,function(){
           this.fire('unlocked');
        }.bind(this));
      },

      createKeystore: function(amountofaccounts, fn) {
        if (!this.password) {
          throw new Error('no password set for creating Vault');
        }

        var self = this;
        lightwallet.keystore.createVault({
          password: this.password,
        }, function(err, ks) {
          if (err) {
            throw new Error(err);
          }
          self.keystore = ks;

          if (amountofaccounts==0){
            self.currentidentity = {
              version: 1,
              username: 'MrArc',
              avatarhash: 'https://pbs.twimg.com/profile_images/2431469361/Wc0d22FE_400x400'
            };

            self.saveVault();
            self.loadVault();

            if (fn) {
              fn();
            }
            return;            
          }

          self.generateNewAddress(1,function() {
            //self._currentAccount();

            self.currentidentity = {
              version: 1,
              username: 'MrArc',
              avatarhash: 'https://pbs.twimg.com/profile_images/2431469361/Wc0d22FE_400x400'
            };

            self.saveVault();
            self.loadVault();

            if (fn) {
              fn();
            }
          });
        });
      },

      _getpwDerivedKey: function(cb){
        if (this.pwDerivedKey){
          return cb(null,this.pwDerivedKey);
        }
        if (!this.password){
          throw new Error('no password set');
        }
        var self=this;
        self.keystore.keyFromPassword(self.password, function(err, pwDerivedKey) {
            if (err){
              return cb(err);
            }
            self.pwDerivedKey = pwDerivedKey;
            cb(null,pwDerivedKey);
          });
      },

      generateNewAddress: function(amount,cb) {
        if (!this.keystore) {
          throw new Error('no keystore available');
        }
        var self = this;
        this._getpwDerivedKey(function(err,pwDerivedKey ) {
          self.keystore.generateNewAddress(pwDerivedKey, amount || 1);
          cb();
        });
      },

      _currentAccount: function(){
        var addr = this.keystore.getAddresses();
        if (addr.length>0){
          this.currentaccount = self.fixaddress(addr[0]);
        }
      }
    });
  </script>
</dom-module>