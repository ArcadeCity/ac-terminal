<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/app-route/app-route.html">
<link rel="import" href="./ac-helpers.html">
<link rel="import" href="./ac-password.html">

<script src="scripts/lightwallet.min.js"></script>
<link rel="import" href="../bower_components/neon-animation/neon-animation.html">

<dom-module id="ac-vault">

  <template>
    <ac-helpers id="helpers"></ac-helpers>
    <app-route route="{{route}}" pattern="/:page" data="{{data}}"></app-route>

    <neon-animated-pages attr-for-selected="data-page" selected="[[data.page]]" entry-animation="{{entryAnimation}}" exit-animation="{{exitAnimation}}">

      <neon-animatable data-page="pastepk">
        PASTE PK
        <!-- <ac-createwallet on-to-home="toHome"></ac-createwallet> -->
      </neon-animatable>

      <neon-animatable data-page="new">
        <ac-password double sessionname="vaultpassword" on-password-received="createvault"></ac-password>

        <ac-createwallet on-to-home="toHome"></ac-createwallet>
      </neon-animatable>

      <neon-animatable data-page="unlock">
        <ac-password id="newuser" sessionname="vaultpassword" on-password-received="unlockvault"></ac-password>
      </neon-animatable>

    </neon-animated-pages>

    <!--   <iron-localstorage
      id="localstorage"
      name="ac-vault"
      value="{{acvault}}"></iron-localstorage>
  -->
</template>

<script>
    Polymer({

      is: 'ac-vault',

      properties: {
        route: {
          type: Object
        },
        password: {
          type: String,
          observer: '_password'
        },

        keystore: {
          type: Object,
          notify: true,
        },
        // the exposed lightwallet.keystore object
        currentkeystore: {
          type: Object,
          notify: true,
        },
        // the ethereum account assiciated with the current identity
        currentaccount: {
          type: String,
          notify: true,
        },
        // an object containing a set of fields with identity data.
        currentidentity: {
          type: Object,
          notify: true
        }
      },

      attached: function(){
        console.log('ac-vault attached');
        if (!this.hasVault()) {
          return this.fire('novault');
        };
        if (!this.password){
          return this.fire('locked');          
        }
      },

      _password: function(){

      },

      _currentidentity: function(){
        console.log('ac-vault ->','currentidentity updated',this.currentidentity);
      },


      unlockvault: function(e) {
        if (!this.hasVault()) {
          //return page.redirect('/');
          console.log("there is no vault!");
        }
        this.loadVault(e.detail.password);
        console.log("vault loaded!");
        this.fire('unlocked');
        //page.redirect('/home');
      },

      loadVault: function(password){

        this.vault = JSON.parse(window.localStorage.getItem('ac-vault'));

        try{
          if(!this.vault){
            throw new Error('vault is not defined.');
          }
          switch (this.vault.version){
            case 1:
              this.password = password;
              this.keystore = lightwallet.keystore.deserialize(this.vault.keystore);
              this.currentaccount = this.$.helpers.fixaddress(this.keystore.getAddresses()[0]);
              this.currentidentity = this.vault.identity;
              console.log('ac-vault -> Vault opened. Account=',this.currentaccount);
              break;
            default:
              throw new Error('Vault version unknown',this.vault.version);
              break;
          }
        }
        catch(e){
          throw new Error('Vault could not be loaded',e);
        }

      },

      importPrivateKey: function(pk) {
        var self = this;
        this._getpwDerivedKey(function(err, pwDerivedKey) {
          self.keystore.importPrivateKey(pk, pwDerivedKey);
        });
      },

      saveVault: function(){

          var serializedKeystore = this.keystore.serialize();
          var serializedIdentity = this.currentidentity || {};

          var vault = {
            version:1,
            keystore: serializedKeystore,
            identity: serializedIdentity
          };

          //encryption.multiEncryptString(keystore, pwDerivedKey, msg, myPubKey, theirPubKeyArray [, hdPathString])

          window.localStorage.setItem('ac-vault', JSON.stringify(vault));

      },

      hasVault: function(){
        var vault = window.localStorage.getItem('ac-vault');
        return (vault);
      },

      createvault: function(e){
        debugger;
        this.createKeystore(e.detail.password,function(){
           this.fire('unlocked');
        }.bind(this));
      },

      createKeystore: function(_password, fn) {
        if (!_password) {
          throw new Error('no password set for creating Vault');
        }

        this.password = _password;

        var self = this;
        lightwallet.keystore.createVault({
          password: _password,
        }, function(err, ks) {
          if (err) {
            throw new Error(err);
          }
          self.keystore = ks;
          self.generateNewAddress(1,function() {
            //self._currentAccount();

            self.currentidentity = {
              version: 1,
              username: 'MrArc',
              avatarhash: 'https://pbs.twimg.com/profile_images/2431469361/Wc0d22FE_400x400'
            };

            self.saveVault();
            self.loadVault();

            if (fn) {
              fn();
            }

          });


        });

      },

      _getpwDerivedKey: function(cb){
        if (this.pwDerivedKey){
          return cb(null,this.pwDerivedKey);
        }
        if (!this.password){
          throw new Error('no password set');
        }
        var self=this;
        self.keystore.keyFromPassword(self.password, function(err, pwDerivedKey) {
            if (err){
              return cb(err);
            }
            self.pwDerivedKey = pwDerivedKey;
            cb(null,pwDerivedKey);
          });
      },

      generateNewAddress: function(amount,cb) {
        if (!this.keystore) {
          throw new Error('no keystore available');
        }
        var self = this;
        this._getpwDerivedKey(function(err,pwDerivedKey ) {
          self.keystore.generateNewAddress(pwDerivedKey, amount || 1);
          cb();
        });
      },

      _currentAccount: function(){
        var addr = this.keystore.getAddresses();
        if (addr.length>0){
          this.currentaccount = self.fixaddress(addr[0]);
        }
      }
    });
  </script>
</dom-module>